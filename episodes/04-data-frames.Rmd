---
title: Working with Data Frames
teaching: 15
exercises: 0
---

::::::::::::::::::::::::::::::::::::::: objectives

- Describe what a data frame is.
- Summarize the contents of a data frame.
- Indexing and subsetting data frames.
- Explore missing values in data frames.
- Use logical operators in data frames.

::::::::::::::::::::::::::::::::::::::::::::::::::

:::::::::::::::::::::::::::::::::::::::: questions

- What is a data frame?
- How can I get basic summary information about my dataset?
- How can I extract certain rows and columns from my data frame?
- How can I deal with missing values in R?

::::::::::::::::::::::::::::::::::::::::::::::::::

```{r, include=FALSE}
source("files/download_data.R")
library(readr)
books <- read_csv("./data/books.csv")
```


## Data frames and tibbles

Data frames are the *de facto* data structure for tabular data in `R`, and what
we use for data processing, statistics, and plotting.

A **data frame** is the representation of data in the format of a table where the
columns are vectors that all have the same length. Because columns are vectors,
each column must contain a single type of data (e.g., characters, integers,
factors). For example, here is a figure depicting a data frame comprising a
numeric, a character, and a logical vector.

```{r, echo=FALSE, fig.alt="A graphical depiction of a data frame. The first vector (column) is numeric; the second is character, and the third is logical."}
knitr::include_graphics("fig/data-frame.svg")
```

A data frame can be created by hand, but most commonly they are generated by the
functions `read_csv()` or `read_table()`; in other words, when importing
spreadsheets from your hard drive (or the web).

A **tibble** is an extension of `R` data frames used by the *tidyverse*. When the
data is read using `read_csv()`, it is stored in an object of class `tbl_df`,
`tbl`,  and `data.frame`. You can see the class of an object with `class()`.


## Inspecting data frames

When calling a `tbl_df` object (like `books` here), there is already a 
lot of information about our data frame being displayed such as the number 
of rows, the number of columns, the names of the columns, and as we just 
saw the class of data stored in each column. However, there are functions 
to extract this information from data frames.  Here is a non-exhaustive list 
of some of these functions. Let's try them out!

### Size and dimensions

```{r, purl=FALSE, eval=FALSE}
dim(books)  # returns a vector with the number of rows in the first element, 
and the number of columns as the second element (the **dim**ensions of the object)
nrow(books)  # returns the number of rows
ncol(books)  # returns the number of columns
```

### Content

To examine the contents of a data frame.

```{r, purl=FALSE, eval=FALSE}
head(books)  # shows the first 6 rows
tail(books)  # shows the last 6 rows
```

### Names

```{r, purl=FALSE, eval=FALSE}
names(books)  # returns the column names (synonym of `colnames()` for 
`data.frame` objects)
```

### Summary

```{r, purl=FALSE, eval=FALSE}
View(books)  # look at the data in the viewer
str(books)  # structure of the object and information about the class, 
length and content of each column
summary(books)  # summary statistics for each column
```

Note: Most of these functions are "generic", they can be used on other types of
objects besides data frames.

The `map()` function from `purrr` is a useful way of running a function on all
variables in a data frame or list. If you loaded the `tidyverse` at the
beginning of the session, you also loaded `purrr`. Here we call `class()` on
`books` using `map_chr()`, which will return a character vector of the classes
for each variable.

```{r expl2, comment=NA}
map_chr(books, class)
```


## Indexing and subsetting data frames

Our `books` data frame has 2 dimensions: rows (observations) and columns
(variables). If we want to extract some specific data from it, we need to
specify the "coordinates" we want from it. 

In the last session, we used square brackets `[ ]` to subset values from vectors. 
Here we will do the same thing for data frames, but we can now add a second dimension. 
Row numbers come first, followed by column numbers. However, note that different 
ways of specifying these coordinates lead to results with different classes.

```{r, purl=FALSE, eval=FALSE}
## first element in the first column of the data frame (as a vector)
books[1, 1]
## first element in the 6th column (as a vector)
books[1, 6]
## first column of the data frame (as a vector)
books[[1]]
## first column of the data frame (as a data.frame)
books[1]
## first three elements in the 7th column (as a vector)
books[1:3, 7]
## the 3rd row of the data frame (as a data.frame)
books[3, ]
## equivalent to head_books <- head(books)
head_books <- books[1:6, ]
```


### Dollar sign

The dollar sign `$` is used to distinguish a specific variable (column, in Excel-speak) 
in a data frame:

```{r expl1, comment=NA}
head(books$X245.ab)  # print the first six book titles


# print the mean number of checkouts
mean(books$TOT.CHKOUT)
```


### `unique()`, `table()`, and `duplicated()`

Use `unique()` to see all the distinct values in a variable:

```{r expl111, comment=NA}
unique(books$BCODE2)
```

Take one step further with `table()` to get quick frequency counts on a variable:

```{r expl11, comment=NA}
table(books$BCODE2)  # frequency counts on a variable
```

You can combine `table()` with relational operators:

```{r, purl=FALSE}
table(books$TOT.CHKOUT > 50)  # how many books have 50 or more checkouts?
```

`duplicated()` will give you the a logical vector of duplicated values.

```{r expl1111, comment=NA, eval=FALSE}
duplicated(books$ISN)  # a TRUE/FALSE vector of duplicated values in the ISN column
!duplicated(books$ISN)  # you can put an exclamation mark before it to get non-duplicated values
table(duplicated(books$ISN))  # run a table of duplicated values
which(duplicated(books$ISN))  # get row numbers of duplicated values
```


## Explore missing values

You may also want to know the number of missing values:

```{r expl3, comment=NA}
sum(is.na(books))  # How many total missing values?
colSums(is.na(books))  # Total missing values per column
table(is.na(books$ISN))  # use table() and is.na() in combination
booksNoNA <- na.omit(books)  # Return only observations that have no missing values
```

:::::::::::::::::::::::::::::::::::::::  callout

Recall how we use `na.rm`, `is.na()`, `na.omit()`, and `complete.cases()` when 
dealing with vectors.

:::::::::::::::::::::::::::::::::::::::  


:::::::::::::::::::::::::::::::::::::::  challenge

## Exercise

1. Call `View(books)` to examine the data frame. Use the small arrow buttons
  in the variable name to sort tot\_chkout by the highest checkouts. What item has
  the most checkouts?

2. What is the class of the TOT.CHKOUT variable?

3. Use `table()` and `is.na()` to find out how many NA values are in the ISN variable.

4. Call `summary(books$TOT.CHKOUT)`. What can we infer when we compare the mean, median, and max?

5. `hist()` will print a rudimentary histogram, which displays frequency counts. Call `hist(books$TOT.CHKOUT)`. What is this telling us?

:::::::::::::::  solution

## Solution

1. Highest checkouts: `Click, clack, moo : cows that type.`

2. `class(books$TOT.CHKOUT)` returns `numeric`

3. `table(is.na(books$ISN))` returns 2934 `TRUE` values

4. The median is 0, indicating that, consistent with all book circulation I
  have seen, the majority of items have 0 checkouts.

5. As we saw in `summary()`, the majority of items have a small number of checkouts

:::::::::::::::::::::::::

::::::::::::::::::::::::::::::::::::::::::::::::::


## Logical tests

R contains a number of operators you can use to compare
values. Use `help(Comparison)` to read the R help file. 


| operator | function                 | 
| -------- | ------------------------ |
| `<`         | Less Than                | 
| `>`         | Greater Than             | 
| `==`         | Equal To                 | 
| `<=`         | Less Than or Equal To    | 
| `>=`         | Greater Than or Equal To | 
| `!=`         | Not Equal To             | 
| `%in%`         | Has a Match In           | 
| `is.na()`         | Is NA                    | 
| `!is.na()`         | Is Not NA                | 


:::::::::::::::::::::::::::::::::::::::  callout

Note that **two equal signs** (`==`) are used for evaluating equality 
because one equals sign (`=`) is used for assigning variables.

:::::::::::::::::::::::::::::::::::::::  


A simple logical test using numeric comparison:

```{r, purl=FALSE}
1 < 2


1 > 2
```

Sometimes you need to do multiple logical tests (think Boolean logic). Use
`help(Logic)` to read the help file.

| operator | function                 | 
| -------- | ------------------------ |
| `&`         | boolean AND              | 
| \`        | \`                        | 
| `!`         | Boolean NOT              | 
| `any()`         | Are some values true?    | 
| `all()`         | Are all values true?     | 


### Logical Subsetting

We can use logical operators to subset our data, just like how we use the square 
brackets `[]` for subsetting.

For instance, if we want to extract rows with *Total Checkout Number* of more than 5:

```{r, purl=FALSE, eval=FALSE}
books[books$TOT.CHKOUT > 5, ]
```

:::::::::::::::::::::::::::::::::::::::  discussion

Compare the output of the following codes to the previous one:

```{r, purl=FALSE, eval=FALSE}
books$TOT.CHKOUT > 5
books[books$TOT.CHKOUT > 5]
```

What differences did you see in the output?

:::::::::::::::::::::::::::::::::::::::  



:::::::::::::::::::::::::::::::::::::::: keypoints

- Data frames are made up of vectors of equal length, with each vector 
representing each column of the data frame.
- Summarise the dimension, content and variables in a data frame.
- Using the square brackets `[]` and logical operators to subset data frames.

::::::::::::::::::::::::::::::::::::::::::::::::::


